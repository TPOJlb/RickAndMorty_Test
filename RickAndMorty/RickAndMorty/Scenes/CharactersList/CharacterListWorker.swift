//
//  CharacterListWorker.swift
//  RickAndMorty
//
//  Created by Muraviov Kyrylo on 30.03.2025.
//  Copyright (c) 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import Foundation
import Alamofire
import CoreData

class CharacterListWorker {
    
    // MARK: - Internal vars
    private let coreDataManager = CoreDataManager.shared
    private let baseURL = "https://rickandmortyapi.com/api/character"
    private var nextPage: String?
    private var previusPage: String?
    private var sendURL: String?
    private let characterFetchQueue: OperationQueue = {
        let queue = OperationQueue()
        queue.qualityOfService = .userInitiated
        queue.maxConcurrentOperationCount = 1
        return queue
    }()
    private let imageDownloadQueue: OperationQueue = {
        let queue = OperationQueue()
        queue.qualityOfService = .utility
        queue.maxConcurrentOperationCount = OperationQueue.defaultMaxConcurrentOperationCount
        return queue
    }()
    
    // MARK: - External logic
    func fetchCharacters(completion: @escaping ([CharacterEntity]) -> Void) {
        let url: String? = nextPage ?? (previusPage != nil ? nil : baseURL)
        guard let url else { return }
        if let sendURL, sendURL == url { return }
        sendURL = url
        
        characterFetchQueue.addOperation {
            let semaphore = DispatchSemaphore(value: 0)
            
            AF.request(url).responseDecodable(of: CharacterResponse.self) { response in
                switch response.result {
                case .success(let data):
                    guard let results = data.results else {
                        semaphore.signal()
                        return
                    }
                    self.saveCharacters(results, completion: completion)
                    self.nextPage = data.info?.next
                    self.previusPage = data.info?.prev
                case .failure:
                    completion(self.fetchFromCoreData())
                }
                semaphore.signal()
            }
            semaphore.wait()
        }
    }
    
    
    func pageZeroing() {
        nextPage = nil
        previusPage = nil
    }
    
    func fetchFromCoreData() -> [CharacterEntity] {
        let request = NSFetchRequest<CharacterEntity>(entityName: "CharacterEntity")
        let sortDescriptor = NSSortDescriptor(key: "id", ascending: true)
        request.sortDescriptors = [sortDescriptor]
        return (try? coreDataManager.context.fetch(request)) ?? []
    }
    
    // MARK: - Internal logic
    private func saveCharacters(_ characters: [Character], completion: @escaping ([CharacterEntity]) -> Void) {
        let context = coreDataManager.context
        let fetchRequest = NSFetchRequest<CharacterEntity>(entityName: "CharacterEntity")
        let existingCharacters = (try? context.fetch(fetchRequest))?.reduce(into: [Int64: CharacterEntity]()) {
            $0[$1.id] = $1
        } ?? [:]
        
        var entities: [CharacterEntity] = []
        
        for character in characters {
            guard let characterStringID = character.id else { return }
            let characterID = Int64(characterStringID)
            
            if let existingCharacter = existingCharacters[characterID] {
                
                if existingCharacter.name != character.name {
                    existingCharacter.name = character.name
                }
                
                if existingCharacter.imageUrl != character.image {
                    existingCharacter.imageUrl = character.image
                    if let imageUrl = character.image {
                        downloadImage(url: imageUrl, entity: existingCharacter)
                    }
                }
                
                if existingCharacter.gender != character.gender {
                    existingCharacter.gender = character.gender
                }
                
                if existingCharacter.status != character.status {
                    existingCharacter.status = character.status
                }
                
                if existingCharacter.created != character.created {
                    existingCharacter.created = character.created
                }
                
                if existingCharacter.species != character.species {
                    existingCharacter.species = character.species
                }
                
                if existingCharacter.imageData == nil, let imageUrl = character.image {
                    downloadImage(url: imageUrl, entity: existingCharacter)
                }
                
                entities.append(existingCharacter)
            } else {
                let entity = CharacterEntity(context: context)
                entity.id = characterID
                entity.name = character.name
                entity.imageUrl = character.image
                entity.gender = character.gender
                entity.status = character.status
                entity.created = character.created
                entity.species = character.species
                
                if let imageUrl = character.image {
                    downloadImage(url: imageUrl, entity: entity)
                }
                
                entities.append(entity)
            }
        }
        
        do {
            try context.save()
            completion(entities)
        } catch {
            print("Ошибка сохранения: \(error)")
        }
    }
    
    private func downloadImage(url: String, entity: CharacterEntity) {
        let operation = BlockOperation {
            AF.request(url).responseData { response in
                switch response.result {
                case .success(let data):
                    DispatchQueue.main.async {
                        entity.imageData = data
                        self.coreDataManager.saveContext()
                        NotificationCenter.default.post(name: NSNotification.Name("ImageDownloaded"), object: nil, userInfo: ["id": entity.id, "data": data])
                    }
                case .failure:
                    break
                }
            }
        }
        imageDownloadQueue.addOperation(operation)
    }
}
